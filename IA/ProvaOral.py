# -*- coding: utf-8 -*-
"""ProvaOral.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p4JZfctmRsI9hGLuC4mYkk1Mqa_jOnE4

A atividade consiste em resolver um problema de labirinto. O objetivo é encontrar uma rota que liga o
ponto de partida ao ponto de chegada enquanto minimiza a quantidade de lâmpadas acesas ao longo
do caminho. O código fornecido gera essa grade e a distribuição de lâmpadas, utilizando uma chave
de semente específica, no meu caso meuSeed = 24680.

Abaixo vai estar o código do repositório implementado:
"""

from random import choice, seed
from collections import deque

class Cruzamento:
    def __init__(self, lin, col):
        # Inicializa um dicionário para armazenar as saídas do cruzamento.
        # Cada chave representa uma direção (0 a 7) e o valor é uma tupla (número de lâmpadas, destino).
        self.saídas = {0: None, 1: None, 2: None, 3: None, 4: None, 5: None, 6: None, 7: None}

        # Armazena a linha e a coluna do cruzamento na grade.
        self.lin = lin
        self.col = col

        # Cria um nome para o cruzamento baseado em sua posição na grade.
        self.nome = f'([{lin}], [{col}])'

    def addSaida(self, saída, lamps, destino):
        # Adiciona uma saída do cruzamento atual para um destino específico.
        # 'saída' é a direção da saída, 'lamps' é o número de lâmpadas, e 'destino' é o cruzamento de destino.
        self.saídas[saída] = (lamps, destino)

        # Calcula a direção de retorno (oposta) para garantir que a saída seja bidirecional.
        retorno = (saída + 4) % 8

        # Se o destino ainda não tem uma saída de retorno, adiciona a saída de retorno.
        if destino.saídas[retorno] == None:
            destino.addSaida(retorno, lamps, self)

    def __str__(self):
        # Cria uma representação em string do cruzamento, incluindo suas saídas.
        node =  self.nome
        for saída, destino in self.saídas.items():
            if destino != None:
                # Adiciona cada saída à string, mostrando a direção, o número de lâmpadas e o nome do destino.
                node += f' -> {saída, destino[0] ,destino[1].nome}'
        return node

# Gerar a grade
gS = 8 # gridSize
grade = [ ]
for lin in range(gS):
    linha = [ ]
    for col in range(gS):
        linha.append(Cruzamento(lin, col))
    grade.append(linha)

qtdLampadas = [1, 3, 5, 7]
meuSeed = 24680
seed(meuSeed)

"""Start: na saída temos três possíveis caminhos com quantidade de lampadas aleatórias"""

grade[0][0].addSaida(2, choice(qtdLampadas), grade[0][1])
grade[0][0].addSaida(1, choice(qtdLampadas), grade[1][1])
grade[0][0].addSaida(0, choice(qtdLampadas), grade[1][0])

"""Stop: na chegada temos três possíveis caminhos com quantidade de lampadas aleatórias"""

grade[7][7].addSaida(6, choice(qtdLampadas), grade[6][6])
grade[7][7].addSaida(5, choice(qtdLampadas), grade[6][5])
grade[7][7].addSaida(4, choice(qtdLampadas), grade[5][6])

"""Preenchendo os cruzamentos do interior da grade com caminhos e lampadas aleatórios"""

direções = [0, 1, 2, 3, 4, 5, 6, 7]
for lin in range(1, gS-1):
    for col in range(1, gS-1):
        vizinhos = {0: grade[lin + 1][col    ],
                    1: grade[lin + 1][col + 1],
                    2: grade[lin    ][col + 1],
                    3: grade[lin - 1][col + 1],
                    4: grade[lin - 1][col    ],
                    5: grade[lin - 1][col - 1],
                    6: grade[lin    ][col - 1],
                    7: grade[lin + 1][col - 1]}
        for direção in direções:
            if (grade[lin][col].saídas[direção] == None) and (choice([True, False])):
                grade[lin][col].addSaida(direção, choice(qtdLampadas), vizinhos[direção])

"""Algoritmos Implementados:

1.Busca em Largura (BFS) -> Código que eu usei para comparar com o da questão.

2.Busca Iterativa em Profundidade (IDDFS) -> Código da questão 5 que foi sorteada.

Obs: Ambos foram modificados para levar em conta o número de lâmpadas nos corredores, já que o objetivo não é apenas encontrar um caminho, mas sim o caminho com o menor número de lâmpadas.

1. Busca em Largura (BFS):

O algoritmo de busca em largura (BFS) percorre a grade de cruzamentos de forma "ampla", visitando
todos os vizinhos de um cruzamento antes de avançar para o próximo nível. Ele é ideal para encontrar
o caminho mais curto em termos de quantidade de passos.

Obs: Contudo, o desafio desta atividade é minimizar a quantidade de lâmpadas, e não o número de
passos.
"""

def bfs(start, goal):
    # Inicializa a fila com uma tupla contendo o nó inicial e a soma de lâmpadas até ele (inicialmente 0)
    fila = deque([(start, 0)])

    # Inicializa o dicionário para rastrear o caminho e o número de lâmpadas usadas
    # O valor é uma tupla contendo o nó anterior e a soma de lâmpadas até o nó atual
    caminho = {start: (None, 0)}

    while fila:
        # Remove o nó da frente da fila e obtém o número de lâmpadas até ele
        atual, lampadas_atuais = fila.popleft()

        # Verifica se o nó atual é o objetivo
        if atual == goal:
            break

        # Explora as saídas do nó atual
        for direção, destino in atual.saídas.items():
            if destino is not None:
                # Calcula o custo (número de lâmpadas) para o próximo cruzamento
                prox_custo = lampadas_atuais + destino[0]
                prox_cruzamento = destino[1]

                # Se o próximo cruzamento não foi visitado ou se o novo custo é menor, atualiza a fila e o caminho
                if prox_cruzamento not in caminho or prox_custo < caminho[prox_cruzamento][1]:
                    fila.append((prox_cruzamento, prox_custo))
                    caminho[prox_cruzamento] = (atual, prox_custo)

    # Reconstituir o caminho final a partir do objetivo
    caminho_final = []
    lampadas_totais = 0
    passo = goal
    while passo is not None:
        # Adiciona o nome do cruzamento ao caminho final
        caminho_final.append(passo.nome)

        # Move para o nó anterior no caminho
        passo = caminho[passo][0]

    # Inverte o caminho para começar do início
    caminho_final.reverse()

    # Retorna o caminho final e o número total de lâmpadas usadas
    return caminho_final, caminho[goal][1]

"""Modificação:

A modificação principal no algoritmo BFS foi incluir o cálculo do número de lâmpadas. Ao visitar um
cruzamento, o algoritmo agora acumula o número de lâmpadas que foram acesas ao longo do caminho
e, se encontrar uma rota que acende menos lâmpadas para o mesmo cruzamento, ele atualiza o
caminho. Essa abordagem permite que o BFS continue buscando de forma ampla, mas priorizando os
caminhos que utilizam menos lâmpadas.

Relação com o Código do Repositório:

O código fornecido gera os corredores e as lâmpadas entre os cruzamentos, com base em direções
aleatórias e a chave de semente fornecida (meuSeed). A partir dessa grade gerada, o algoritmo BFS
utiliza as saídas dos cruzamentos (Norte, Nordeste, Leste, etc.) para encontrar o caminho com o
menor número de lâmpadas

2. Busca Iterativa em Profundidade (IDDFS):

O algoritmo de busca iterativa em profundidade (IDDFS) é uma variação da busca em profundidade,
onde exploramos os caminhos até um limite de profundidade. A cada iteração, esse limite é aumentado, o que garante que exploremos caminhos mais curtos antes de tentar caminhos mais profundos. Esse algoritmo é interessante porque combina a exaustividade da busca em profundidade com a garantia de que os caminhos mais curtos serão examinados primeiro, de forma similar ao BFS, mas sem a necessidade de memória intensiva.
"""

def dfs_limitado(atual, goal, limite, caminho, lampadas_atuais, melhor_caminho, melhor_lampadas):
    # Se o limite for 0 e o nó atual for o objetivo, retorna True (objetivo encontrado)
    if limite == 0 and atual == goal:
        return True

    # Se o limite for maior que 0, continua a busca
    if limite > 0:
        # Explora as saídas do nó atual
        for direção, destino in atual.saídas.items():
            # Verifica se a saída é válida e se o nó destino não está no caminho
            if destino is not None and destino[1] not in caminho:
                # Adiciona o nó destino ao caminho
                caminho.add(destino[1])
                # Calcula o novo número de lâmpadas até o nó destino
                lampadas_novas = lampadas_atuais + destino[0]

                # Chama a função recursiva para o próximo nó, diminuindo o limite
                if dfs_limitado(destino[1], goal, limite - 1, caminho, lampadas_novas, melhor_caminho, melhor_lampadas):
                    # Se o novo número de lâmpadas for menor que o melhor encontrado, atualiza o melhor caminho e o número de lâmpadas
                    if lampadas_novas < melhor_lampadas[0]:
                        melhor_lampadas[0] = lampadas_novas
                        melhor_caminho.clear()
                        melhor_caminho.update(caminho)
                    return True

                # Remove o nó destino do caminho (backtracking)
                caminho.remove(destino[1])

    # Se não encontrar o objetivo, retorna False
    return False

def iddfs(start, goal, limite_max):
    melhor_caminho = set()
    melhor_lampadas = [float('inf')]
    for limite in range(limite_max):
        caminho = set([start])
        if dfs_limitado(start, goal, limite, caminho, 0, melhor_caminho, melhor_lampadas):
            return melhor_caminho, melhor_lampadas[0]
    return None, float('inf')

"""A criação de uma função dfs_limitado separada da função iddfs foi por conta da busca iterativa em
profundidade (IDDFS) que explora progressivamente os caminhos com um limite crescente de
profundidade, enquanto a função dfs_limitado realiza uma busca em profundidade até o limite atual

Modificação:

A modificação no IDDFS, assim como no BFS, foi incluir o cálculo da quantidade de lâmpadas. Em
cada profundidade, o algoritmo acumula o número de lâmpadas acesas e compara para encontrar a
rota que utiliza o menor número delas

Relação com o Código do Repositório:

O código do repositório, que define as saídas entre os cruzamentos e suas respectivas lâmpadas, foi
essencial para implementar essa variação do IDDFS. A cada iteração, o algoritmo verifica se o
caminho até o objetivo (linha 7, coluna 7) pode ser alcançado dentro do limite de profundidade, e se o
número de lâmpadas é menor que a melhor solução encontrada até então.

Agora basta executar os algoritmos implementados.

Iniciando com o algoritmo BFS:
"""

start = grade[0][0]
goal = grade[7][7]
caminho_bfs, lampadas_bfs = bfs(start, goal)
print("Caminho BFS:", caminho_bfs)
print("Lâmpadas no caminho BFS:", lampadas_bfs)

"""Executando a busca IDDFS:"""

limite_max = 20
caminho_iddfs, lampadas_iddfs = iddfs(start, goal, limite_max)
if caminho_iddfs:
    print("Caminho IDDFS:", [cruzamento.nome for cruzamento in caminho_iddfs])
    print("Lâmpadas no caminho IDDFS:", lampadas_iddfs)
else:
    print("Nenhum caminho encontrado com IDDFS.")

"""Conclusão:

Enquanto a BFS encontra o caminho mais curto em termos de números de arestas mas não otimiza o
custo (número de lâmpadas), o IDDFS pode encontrar um caminho com menos lâmpadas se esse
caminho estiver dentro do limite de profundidade atual, explorando diferentes caminhos em
profundidades diferentes.
"""